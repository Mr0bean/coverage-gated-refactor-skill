# backend_typescript_json-file-storage

## 适用场景

- `lib/db.ts` 与 `data/*.json` 的文件型存储重构

## 重构思路

1. 存储适配层抽象：读写、迁移、初始化分层，避免路由层直接操纵文件细节。
2. 原子写策略：先写临时文件再替换，降低写中断导致的数据损坏风险。
3. schema 演进机制：版本号与迁移函数清晰，兼容历史数据结构。
4. 读写收敛：所有数据访问统一走 repository/store，禁止散点读写。
5. 逐步解耦：预留接口为后续切换 SQLite/Postgres 做兼容垫层。

## 合规思路

1. 数据最小化：仅持久化业务必要字段，敏感字段加密或避免落盘。
2. 数据完整性：写入前后校验结构，异常写入可回滚。
3. 审计可追踪：关键变更记录时间、操作者、影响对象。
4. 保留与删除策略：定义数据保留周期和清理机制。
5. 恢复合规：定义备份与恢复流程，支持审计复盘。

## 规范清单

1. 文件结构规范：每张“表”固定 `version/updatedAt/records` 结构。
2. ID 规范：ID 生成策略统一，禁止各模块自定义冲突策略。
3. 时间规范：统一 UTC 时间戳，避免本地时区写入。
4. 并发规范：同一资源写操作串行化或加锁。
5. 迁移规范：每次 schema 变更必须带迁移函数和回归测试。
6. 回滚规范：写入失败时保证文件可恢复到上一个有效版本。
7. 权限规范：仅服务进程可写数据目录。
8. 注释规范：迁移和异常恢复逻辑必须写注释。

## 可参考操作方法

1. 建立基线：导出当前 JSON schema 与示例数据快照。
2. 拆 store：把 `read/write/bootstrap/migrate` 独立模块化。
3. 实现原子写：`write tmp -> fsync -> rename`。
4. 加结构校验：读写入口加入 schema 校验（如 zod/custom validator）。
5. 加并发控制：写接口加入锁或写队列。
6. 补迁移测试：对历史版本样本执行迁移回归。
7. 发布前演练：模拟写失败、损坏文件、回滚恢复流程。

## 最佳实践

1. 统一读写入口：所有 JSON 存取经单一 store 模块。
2. 并发安全：避免并发写冲突，必要时加锁或串行队列。
3. 迁移可测试：每个版本迁移配套测试样例。
4. 演进路径明确：文件存储到 DB 的切换预留接口契约。
5. 写操作最小化：批量写合并，减少频繁 I/O。
