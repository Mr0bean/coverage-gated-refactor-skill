# backend_python_flask-microservice

## 适用场景

- `microservice/pdf-dealer/app.py` Flask 微服务重构

## 重构思路

1. 路由与处理逻辑拆分：`app.py` 保持入口，核心转换逻辑下沉到独立模块。
2. 统一请求与响应契约：明确输入二进制 PDF、输出 JSON 结构与错误字段。
3. 资源控制优先：为大文件处理加入超时、大小限制、异常兜底。
4. 功能职责分离：`pdf->image`、`count pages`、错误处理分别独立函数。
5. 可替换策略：把 PDF 引擎调用封装为适配层，降低后续替换成本。

## 合规思路

1. 文件处理合规：限制文件大小、页数与处理时长，防止资源滥用。
2. 运行时安全：生产禁用 debug，异常返回不泄露内部堆栈。
3. 依赖合规：固定依赖版本并做漏洞扫描，避免高危包漂移。
4. 服务访问合规：仅开放必要接口与方法，避免泛化文件上传端点。
5. 资源合规：限制内存峰值和并发，避免服务雪崩影响主系统。

## 规范清单

1. 入口规范：`app.py` 仅处理路由注册与配置加载。
2. 响应规范：统一 `success`、`error`、`code`、`data` 字段结构。
3. 异常规范：业务异常与系统异常分层处理。
4. 参数规范：请求体为空、格式错误、超限需明确返回 4xx。
5. 配置规范：端口、超时、限制项通过环境变量配置。
6. 运行规范：开发/生产启动命令分离，禁止生产 `debug=True`。
7. 依赖规范：`requirements.txt` 固定版本并定期复审。
8. 日志规范：日志分级，敏感数据脱敏。

## 可参考操作方法

1. 抽函数：把 PDF 转换过程拆为 `decode->convert->encode->respond`。
2. 加限流：在入口增加文件大小、页数和处理超时限制。
3. 标准化错误：建立错误码映射（参数错误/处理失败/系统异常）。
4. 增测试：空输入、损坏 PDF、超页 PDF、正常 PDF 覆盖。
5. 增健康检查：增加轻量 `/health` 端点用于容器探针。
6. 生产化启动：补 gunicorn 启动参数模板和并发配置建议。
7. 联调回归：与 TS 侧调用链做契约回归测试。

## 最佳实践

1. Flask 路由薄化：`request` 解析和业务转换分离。
2. 错误处理标准化：统一返回 `success/error/code`。
3. 处理链可测：核心函数纯函数化，针对空文件/损坏文件/超大文件写测试。
4. 进程模型清晰：开发与生产启动方式区分（Flask dev server vs gunicorn）。
5. 对 CPU 密集任务设置队列或并发上限，避免阻塞全局请求。
